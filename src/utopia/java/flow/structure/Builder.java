package utopia.java.flow.structure;

import java.util.Iterator;

import utopia.java.flow.structure.iterator.RichIterator;
import utopia.java.flow.util.Counter;

/**
 * Builders are used for building immutable data structures in mutable fashion
 * @author Mikko Hilpinen
 * @param <Result> The type of item generated by this builder
 * @param <Buffer> The type of mutable buffer used by this builder
 * @param <Item> The type of items added to the buffer
 * @since 3.8.2018
 */
public abstract class Builder<Result extends Iterable<? extends Item>, Buffer, Item> 
		implements RichIterable<Item>
{
	// ATTRIBUTES	----------------
	
	private Option<Integer> count = Option.some(0);
	private Option<Result> currentResult = Option.none();
	private Buffer buffer;
	
	
	// CONSTRUCTOR	----------------
	
	/**
	 * Creates a new builder
	 * @param buffer The initial buffer
	 */
	public Builder(Buffer buffer)
	{
		this.buffer = buffer;
	}
	
	
	// ABSTRACT	--------------------
	
	/**
	 * @param buffer The buffer that is used
	 * @return An immutable result of the mutable buffer. The buffer will not be 
	 * altered after this call.
	 */
	protected abstract Result newResultFrom(Buffer buffer);
	
	/**
	 * @param old The previous buffer
	 * @return Creates a new mutable buffer with the same contents as the previous buffer
	 */
	protected abstract Buffer copyBuffer(Buffer old);
	
	/**
	 * Adds an item to the target buffer
	 * @param buffer The target buffer
	 * @param newItem The new item
	 */
	protected abstract void append(Buffer buffer, Item newItem);
	
	/**
	 * Retrieves iterator from target buffer
	 * @param buffer Buffer used by this builder
	 * @return Provides an iterator for the buffer
	 */
	protected abstract RichIterator<Item> iteratorFrom(Buffer buffer);
	
	
	// IMPLEMENTED	----------------
	
	@Override
	public RichIterator<Item> iterator()
	{
		if (currentResult.isDefined())
			return RichIterator.wrap(currentResult.get().iterator());
		else
			return iteratorFrom(buffer);
	}
	
	@Override
	public Option<Integer> estimatedSize()
	{
		return count;
	}
	
	
	// ACCESSORS	----------------
	
	/**
	 * @return The underlying buffer instance. The buffer is for reading and should not be 
	 * modified through this method call!
	 */
	protected Buffer getBuffer()
	{
		return buffer;
	}
	
	
	// OTHER	--------------------
	
	/**
	 * @return A new immutable result from this builder
	 */
	public Result result()
	{
		if (currentResult.isDefined())
			return currentResult.get();
		else
		{
			Result result = newResultFrom(buffer);
			currentResult = Option.some(result);
			return result;
		}
	}
	
	/**
	 * @return A new immutable result from this builder
	 * @deprecated Please move to using {@link #result()} instead
	 */
	public Result build()
	{
		return result();
	}
	
	/**
	 * Adds a new item to this buffer
	 * @param item The item to be added
	 */
	public void add(Item item)
	{
		revalidate();
		count = count.map(c -> c + 1);
		append(buffer, item);
	}
	
	/**
	 * Adds multiple items to this buffer
	 * @param items The items to be added
	 */
	public void add(RichIterable<? extends Item> items)
	{
		revalidate();
		count = count.flatMap(c -> items.estimatedSize().map(s -> c + s));
		items.forEach(i -> append(buffer, i));
	}
	
	/**
	 * Adds items to this buffer
	 * @param first The first item to add
	 * @param second The second item to add
	 * @param more More items to add
	 */
	public void add(Item first, Item second, 
			@SuppressWarnings("unchecked") Item... more)
	{
		add(ImmutableList.withValues(first, second, more));
	}
	
	/**
	 * Reads all remaining items from an iterator and adds them to this builder
	 * @param iterator The iterator items are read from
	 */
	public void read(Iterator<? extends Item> iterator)
	{
		revalidate();
		if (count.isDefined())
		{
			Counter itemCounter = new Counter(0, 1);
			iterator.forEachRemaining(i -> 
			{
				append(buffer, i);
				itemCounter.next();
			});
			count = count.map(c -> c + itemCounter.next());
		}
		else
			iterator.forEachRemaining(i -> append(buffer, i));
	}
	
	private void revalidate()
	{
		if (currentResult.isDefined())
		{
			buffer = copyBuffer(buffer);
			currentResult = Option.none();
		}
	}
}
